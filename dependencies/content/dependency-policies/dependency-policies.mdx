# Dependency Policies

Component dependnecies are defined in Bit through dependency policies. A dependency policy is definition of a set of dependencies, with a [SemVer](https://semver.org) range, allowed to use from components 
in your development workspace. Dependencies are set to components upon usage through an `import` or a `require` statement. 

Defining a dependency policy in the Workspace can be done by configuring the `teambit.dependnecies/dependency.resolver` key in `workspace.json`.

```json
{
  "teambit.dependencies/dependency-resolver": {
    "policy": {
      "dependencies": {
        "lodash": "^4.17.0",
        "classnames": "~4.17.0"
      }
    }
  }
}
```

:::note
Dependencies defined in a Workspace `package.json` are also considered as policy by Bit, but it is recommended to use `workspace.json` for more advanced dependency configuration
features such as force notations. Also, `package.json` and `workspace.json` can be combined on the same workspace. Bit uses both and merges them into a single policy.
:::

In the example above, we are configuring `lodash` and `classnames` to use specific SemVer ranges. Every installation of dependnecies using `bit install` command would install
the latest versions allowed by the defined ranges.

Once adding `lodash` to be used from my one of my components through an `import` or a `require` statement, bit sets `lodash` as a dependency on my component.

```ts
import { get } from 'lodash';
```

To see the new dependnecy defined on my component, you can use `bit show`.

```bash
$ bit show ui/button
```

```bash {6}
┌───────────────────┬────────────────────────────────────────────────────────────┐
│ id                │ myorg.design/ui/button                                     │
├───────────────────┼────────────────────────────────────────────────────────────┤
│ name              │ ui/heading                                                 │
├───────────────────┼────────────────────────────────────────────────────────────┤
│ module name       │ @myorg/design.ui.heading                                   │
├───────────────────┼────────────────────────────────────────────────────────────┤
│ dependencies      │ lodash@4.17.21- (package)                                  │
└───────────────────┴────────────────────────────────────────────────────────────┘
```

As seen above, Bit has detected the use of `lodash` and set this dependency to the `ui/button` component. `classnames` is not defined as a dependency since it is not used
by the component.

To learn about how Bit resolves dependencies, head over to the [Depedency Resolution](/) docs.


## Dev dependencies
`devDependencies` are used only during development but not used in production. Usually dev dependencies are used from test files, documantation and other files that are required
only for component development purposes. In the policy, dev dependencies are set just like any other depenendecy unlike in the `package.json` dependencies entry like in the example
below.

```json
{
  "teambit.dependencies/dependency-resolver": {
    "policy": {
      "dependencies": {
        "@testing-library/react": "~12.0.0"
      }
    }
  }
}
```

Bit automatically resolves dependencies as `devDependencies` when the files using them are classified as [Dev Files](/docs/components/dev-files). By default, different aspects of
bit classify files as `*.composition.*`, `*.docs.*` and `*.test.*`.

For example, using the `@testing-library/react` package only from the test file: `heading.spec.ts` will result in Bit defining the package as a dev dependency of my component. 
In the example below, using `bit show`, you can see which files are classified as dev files and that bit detected @testing-library/react as a dev dependency for my component
as a result.  



```
$ bit show ui/button
```

```bash {6}
┌───────────────────┬─────────────────────────────────────────────────────────────┐
│ id                │ myorg.design/ui/heading                                     │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ scope             │ myorg.design                                                │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ name              │ ui/heading                                                  │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ module name       │ @myorg/design.ui.heading                                    │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ dev files         │ heading.spec.tsx (teambit.defender/tester)                  │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ dependencies      │ ...                                                         │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ dev dependencies  │ @testing-library/react@12.0.0- (package)                    │                                     │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ peer dependencies │ ...                                                         │
└───────────────────┴─────────────────────────────────────────────────────────────┘
```

By using the `@testing-library/react` package from a runtime file such as `button.ts`, Bit will switch the definition of the dependency to be a regular dependency instead.


## Peer dependencies
Peer dependencies are used when a single instance of a module is allowed in a single process. In a component-driven architecture, only apps are the ones to define and decide on 
peer dependencies and their specific versions. Therefore, in Bit, peer dependencies are defined by the component' development env.

To understand this further, you can use `bit show` on a React component in the Workspace. 

```bash
bit show ui/button
```
```
┌───────────────────┬─────────────────────────────────────────────────────────────┐
│ id                │ myorg.design/ui/heading                                     │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ scope             │ myorg.design                                                │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ env               │ teambit.bit/react                                           │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ name              │ ui/heading                                                  │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ module name       │ @myorg/design.ui.heading                                    │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ main file         │ index.ts                                                    │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ dependencies      │ ...                                                         │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ dev dependencies  │ ...                                                         │
├───────────────────┼─────────────────────────────────────────────────────────────┤
│ peer dependencies │ react-dom@^16.8.0 || ^17.0.0-- (package)                    │
│                   │ react@^16.8.0 || ^17.0.0------ (package)                    │
└───────────────────┴─────────────────────────────────────────────────────────────┘
```

In the example above, peer dependencies are set by the configured environment `teambit.bit/react` which is the offcial react development envrionemnt by the Bit team. Our official 
environments sets every React component peer dependencies to include `react` and `react-dom`. Other examples for peer dependencies could be `vue` or even `@teambit/harmony` for Aspects.

Under different circumcisions, it is also possible to define a peer dependencies through the workspace policy. Simply use the `peerDependencies` entry in the policy like
in the example below.

```json
{
  "teambit.dependencies/dependency-resolver": {
    "policy": {
      "peerDependencies": {
        "@testing-library/react": "~12.0.0"
      }
    }
  }
}
```

### Prefer wide ranges
Best practice to prefer the widest range of ranges for peer dependencies, that allows component consumers maxiumum flexability using the component easily from variaty of React
versions that might be of a constraint. Of course, the component has to be complient with all supported versions defined in the range, and breaking changes are an important 
constraint choosing your peer dependencies.

In the example above, we are defining `react` and `react-dom` to support apps the range of 16.8.0 to 17.0.0+. Constraint was that React 16.8.0 include React hooks and components
using hooks can't be used in a React 15.x.x app.

:::tip
Using different versions of peer dependnecies is depending on the use case and can be avhieved through various techniques
For example, React 17+ components using React hooks can be used in the same process through the Adapter pattern method. We offer variaty of components
to address different cases but in general, it is not recommended to do, as it might decrease performence and downgrade dev experience for component consumers.
:::

## Special notations

#### Remove a dependency

Using the `-` sign, dependency policies can be used to remove a dependency. That's especially useful when a dependency is not defined with the correct dependency type.

For example, a module can be "moved" from `dependencies` to `peerDependencies` by removing it from `dependencies` and listing it under `peerDependencies`.

```json title="Removing a dependency and setting it as a peer dependency"
"teambit.dependencies/dependency-resolver": {
    "policy": {
      "dependencies": {
        "enzyme": "-"
      },
      "peerDependencies": {
        "enzyme": "^3.11.0"
      }
    }
```

## Component dependency policy (manually)

`devDependencies` can also be configured directly in the dependency policy. However, this option is only available for component dependency policies, and not for workspace dependency policies (as the latter only describe the modules to be installed).

```json
// Example: setting dev dependencies (note that dev dependencies cannot be used in the workspace dependency policy)
{
  "@teambit.dependencies/dependency-resolver": {
    "policy": {
      "devDependencies": {
        "@testing-library/react": "^12.1.2"
      }
    }
  }
}
```



A component dependency policy will set the type and version of a component's dependency. If that dependency is not already listed in the component's dependency graph (i.e, if it wasn't automatically detected), it will be added.

### Variants

Use the Variants config to apply a dependency policy on a group of components. Components can be selected by their common (relative) directory path or by their namespaces.

```json
{
  "teambit.dependencies/dependency-resolver": {
    "policy": {
      "{ui/**}": {
        "dependencies": {
          "classnames": "1.0.0" // sets 'classnames@1.0.0' as a dependency of all components selected by their 'ui' namespace
        }
      }
    }
  }
}
```

Policies set on one group of components can be overridden by other rules set on a more specific group of components (similarly to CSS selections).

For example:

```json
// Example: override dependency policies by using more specific selectors
{
  "teambit.workspace/variants": {
    "{*}": {
      "teambit.dependencies/dependency-resolver": {
        "policy": {
          "dependencies": {
            "classnames": "1.0.0" // use 'classnames@1.0.0' on all components (using the '*' selector)
          }
        }
      }
    },
    "{ui/**}": {
      "teambit.dependencies/dependency-resolver": {
        "policy": {
          "dependencies": {
            "classnames": "2.0.0" // use 'classnames@2.0.0' on all components with the namespace 'ui' (using the 'ui/**' selector)
          }
        }
      }
    }
  }
}
```

### component.json

Component dependency policies can be configured directly on the component by ejecting its [`component.json`](/component-json). Policies set in the `component.json` file are merged with the ones set via Variants.

```json
// Example: A dependency policy ser directly on an ejected component.json file
{
  "componentId": {
    "name": "ui/text",
    "version": "0.0.1",
    "scope": "company.scope"
  },
  "propagate": true,
  "extensions": {
    "teambit.dependencies/dependency-resolver": {
      "policy": {
        "dependencies": {
          "lodash": "^14.17.21"
        }
      }
    }
  }
}
```

## Component dependency policy (programmatically)

Aspects can sue the Dependency Resolver API to configure the dependency policy for component using them.

### Envs

```ts
getDependencies(component: any): Promise<DependencyList>
```

Returns an object that defines the default dependencies for components handled by this environment.

Use the `getDependencies` service handler to standardize the dependency policy of component using [your Env](../envs/extending-env)

For example:

```ts
import { DependenciesEnv } from '@teambit/envs';

export class MyEnv implements DependenciesEnv {
  // ...

  async getDependencies() {
    return {
      dependencies: {
        react: '-',
      },
      devDependencies: {
        '@types/react': '16.9.43',
        '@types/jest': '~26.0.9',
      },
      peerDependencies: {
        react: '^16.13.1',
        'react-dom': '^16.13.1',
      },
    };
  }
}
```

### Aspects (general)

<!-- TODO -->
